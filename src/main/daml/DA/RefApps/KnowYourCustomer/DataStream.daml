--
-- Copyright (c) 2020, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

module DA.RefApps.KnowYourCustomer.DataStream where

import DA.Foldable
import DA.TimeService.TimeService
import DA.Action

import DA.RefApps.KnowYourCustomer.Types
import DA.RefApps.KnowYourCustomer.Publication
import DA.RefApps.KnowYourCustomer.DataLicense

template EmptyDataStream
  with
    operator: Party
    reference: ObservationReference
    consumers: [Consumer]
    publisher: Publisher
  where
    signatory publisher.party, operator

    key (publisher, reference): (Publisher, ObservationReference)
    maintainer key._1.party

    controller publisher.party, operator can
      AddConsumer: ContractId EmptyDataStream
        with dataLicenseId: ContractId DataLicense
        do
          dataLicense <- fetch dataLicenseId
          assert $ dataLicense.licenseData.reference == reference
          let consumer = dataLicense.licenseData.consumer
          exercise dataLicenseId DataLicense_ClaimRegistered
          create this with consumers = consumer :: consumers

    controller publisher.party can
      StartDataStream: ContractId DataStream
        with
          newObservation: Observation
        do
          assert $ newObservation.label == reference
          now <- fetchTime operator
          forA_ consumers
            \consumer -> do
              let lookupKey = (publisher, consumer, reference)
              oldPublicationIdOpt <- lookupByKey @Publication lookupKey
              (dataLicenseId, dataLicense) <- fetchByKey @RegisteredDataLicense lookupKey
              exercise dataLicenseId RegisteredDataLicense_BeginStreaming
              case oldPublicationIdOpt of
                    Some oldPublicationId -> do
                      exercise oldPublicationId Republish with newObservation
                    None -> do
                      create Publication with
                        observation = newObservation
                        published = now
                        ..
          create DataStream with
            observation = newObservation
            published = now
            lastUpdated = now
            ..

-- Observation values have to be stored in order to publish them to new subscribers
template DataStream
  with
    observation: Observation
    consumers: [Consumer]
    publisher: Publisher
    published: Time
    operator: Party
    lastUpdated: Time
  where
    signatory publisher.party, operator

    key (publisher, observation.label): (Publisher, ObservationReference)
    maintainer key._1.party

    controller publisher.party can
      AddConsumerDuringOperations: ContractId DataStream
        with dataLicenseId: ContractId DataLicense
        do
          dataLicense <- fetch dataLicenseId
          assert $ dataLicense.licenseData.reference == observation.label
          let consumer = dataLicense.licenseData.consumer
          registeredDataLicenseId <- exercise dataLicenseId DataLicense_ClaimRegistered
          exercise registeredDataLicenseId RegisteredDataLicense_BeginStreaming
          create Publication with observation, publisher, consumer, published, operator
          create this with consumers = consumer :: consumers

      UpdateObservation: ContractId DataStream
        with
          time: Time
          newValue: ObservationValue
        do
          let newObservation = observation with time, value = newValue
          live <- forA consumers $ getLive operator publisher observation.label
          forA_ live $ republish newObservation
          let newConsumers = map liveConsumer live
          currentTime <- fetchTime operator
          create this with observation = newObservation, published = currentTime, lastUpdated = currentTime, consumers = newConsumers

      UpdateLicenses: ContractId DataStream
        do
          currentTime <- fetchTime operator
          live <- forA consumers $ getLive operator publisher observation.label
          let newConsumers = map liveConsumer live
          create this with consumers = newConsumers, lastUpdated = currentTime

data Live = Live with
    livePublication : ContractId Publication
    liveConsumer : Consumer
  deriving (Show)

republish : Observation -> Live -> Update ()
republish newObservation (Live oldPublicationId consumer) =
  void $ exercise oldPublicationId Republish with newObservation

getLive
  : Party -> Publisher -> ObservationReference -> Consumer -> Update Live
getLive operator publisher observationLabel consumer = do
  (oldPublicationId, _) <- fetchByKey @Publication lookupKey
  pure $ Live oldPublicationId consumer
 where
  lookupKey = (publisher, consumer, observationLabel)
