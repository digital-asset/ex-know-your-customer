--
-- Copyright (c) 2020, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

daml 1.2
module DA.RefApps.KnowYourCustomer.DataStream where

import DA.Foldable
import DA.TimeService.TimeService
import DA.Action

import DA.RefApps.KnowYourCustomer.Types
import DA.RefApps.KnowYourCustomer.Publication
import DA.RefApps.KnowYourCustomer.DataLicense

-- Observation values have to be stored in order to publish them to new subscribers
template DataStream
  with
    observation: Observation
    consumers: [Consumer]
    publisher: Publisher
    published: Time
    operator: Party
    lastUpdated: Time
  where
    signatory publisher.party, operator

    key (publisher, observation.label): (Publisher, ObservationReference)
    maintainer key._1.party

    controller publisher.party can
      AddConsumerDuringOperations: ContractId DataStream
        with dataLicenseId: ContractId DataLicense
        do
          dataLicense <- fetch dataLicenseId
          assert $ dataLicense.licenseData.reference == observation.label
          let consumer = dataLicense.licenseData.consumer
          registeredDataLicenseId <- exercise dataLicenseId DataLicense_ClaimRegistered
          exercise registeredDataLicenseId RegisteredDataLicense_BeginStreaming
          create Publication with observation, publisher, consumer, published, operator
          create this with consumers = consumer :: consumers

      UpdateObservation: ContractId DataStream
        with
          time: Time
          newValue: ObservationValue
        do
          let newObservation = observation with time, value = newValue
          liveAndExpired <- forA consumers $ getLiveOrExpired operator publisher observation.label
          let (live, expired) = partition isLive liveAndExpired
          forA_ live $ republish newObservation
          forA_ expired expire
          let newConsumers = map liveConsumer live
          currentTime <- fetchTime operator
          create this with observation = newObservation, published = currentTime, lastUpdated = currentTime, consumers = newConsumers

      UpdateLicenses: ContractId DataStream
        do
          currentTime <- fetchTime operator
          liveAndExpired <- forA consumers $ getLiveOrExpired operator publisher observation.label
          let (live, expired) = partition isLive liveAndExpired
          forA_ expired expire
          let newConsumers = map liveConsumer live
          create this with consumers = newConsumers, lastUpdated = currentTime

data LiveOrExpired =
    Live {
      livePublication : ContractId Publication,
      liveConsumer : Consumer
    } |
    Expired {
      expiredPublication : ContractId Publication,
      expiredLicense : ContractId LiveStreamLicense
    } deriving (Show)

republish : Observation -> LiveOrExpired -> Update ()
republish newObservation (Live oldPublicationId consumer) =
  void $ exercise oldPublicationId Republish with newObservation
republish _ _ = error "Republish called for Expired Publication."

expire : LiveOrExpired -> Update ()
expire e@(Expired oldPublicationId licenseKey) = do
  exercise oldPublicationId Close
  exercise licenseKey ExpireLicense
expire _ = error "Expire called for Live Publication."

isLive : LiveOrExpired -> Bool
isLive (Live _ _) = True
isLive _ = False

getLiveOrExpired
  : Party -> Publisher -> ObservationReference -> Consumer -> Update LiveOrExpired
getLiveOrExpired operator publisher observationLabel consumer = do
  (licenseKey, license) <- fetchByKey @LiveStreamLicense lookupKey
  (oldPublicationId, _) <- fetchByKey @Publication lookupKey
  isExpired <- checkIsExpired' license
  if isExpired
    then
      pure $ Expired oldPublicationId licenseKey
    else
      pure $ Live oldPublicationId consumer
 where
  lookupKey = (publisher, consumer, observationLabel)
  checkIsExpired' (LiveStreamLicense licenseData _began) =
      checkIsExpired operator licenseData

checkIsExpired : Party -> LicenseData -> Update Bool
checkIsExpired operator licenseData = do
  currentTime <- fetchTime operator
  pure $ isLicenseExpired licenseData currentTime
